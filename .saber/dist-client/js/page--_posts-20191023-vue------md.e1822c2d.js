(window.webpackJsonp=window.webpackJsonp||[]).push([[55],{116:function(t,e,n){"use strict";n.r(e);var o=n(0),s=function(t){var e,n,o,s,p,r,v,a=(o="post",s="什么是函数式组件",p="函数式组件的特点",r="访问组件属性",v="函数式组件的优点",(e={}).internal=n=void 0,e.contentType="markdown",e.slug="20191023-vue函数式组件",e.content=n,e.title="vue函数式组件",e.layout=o,e.markdownHeadings=[{text:s,slug:s,level:2},{text:p,slug:p,level:2},{text:r,slug:r,level:2},{text:v,slug:v,level:2},{text:"速度",slug:"速度",level:3}],e.excerpt="<p>函数组件(不要与 Vue 的 render 函数混淆)是一个<strong>不包含状态和实例的组件</strong>。</p>\n",e.createdAt=new Date(15717888e5),e.updatedAt=new Date(1571824151806),e.type=o,e.permalink="/posts/20191023-vue函数式组件.html",e.assets={},e.attributes=e,e.prevPost={title:"仿vue-cli搭建属于自己的脚手架",permalink:"/posts/20191006-仿vue-cli搭建属于自己的脚手架.html"},e.nextPost={title:"你不知道的js奇淫技巧",permalink:"/posts/20191210-你不知道的js技巧.html"},e),l=t.options.beforeCreate||[];t.options.beforeCreate=[function(){this.$page=a}].concat(l);["layout","transition"].forEach((function(e){var n=t.options.PageComponent;n&&(t.options[e]=n[e]),void 0===t.options[e]&&(t.options[e]=a[e])})),t.options.name="page-wrapper-"+a.slug.replace(/[^0-9a-z\-]/i,"-")},p=Object(o.a)({},(function(){var t=this,e=t.$createElement,o=t._self._c||e;return o("layout-manager",[o("h2",{attrs:{id:"什么是函数式组件"}},[t._v("什么是函数式组件")]),t._v(" "),o("p",[t._v("函数组件(不要与 Vue 的 render 函数混淆)是一个"),o("strong",[t._v("不包含状态和实例的组件")]),t._v("。")]),t._v(" "),o("p",[t._v("简单的说，就是组件不支持响应式，并且不能通过 this 关键字引用自己。")]),t._v(" "),o("h2",{attrs:{id:"函数式组件的特点"}},[t._v("函数式组件的特点")]),t._v(" "),o("ul",[o("li",[t._v("没有管理任何状态")]),t._v(" "),o("li",[t._v("没有监听任何传递给它的状态")]),t._v(" "),o("li",[t._v("没有生命周期方法")]),t._v(" "),o("li",[t._v("它只是接收一些prop的函数")])]),t._v(" "),o("h2",{attrs:{id:"访问组件属性"}},[t._v("访问组件属性")]),t._v(" "),o("p",[t._v("没有状态或实例，你可能会好奇如何引用数据或方法，Vue为底层的 render 函数提供一个 context 参数对象。")]),t._v(" "),o("p",[t._v("这个 context 参数对象具有下列属性：")]),t._v(" "),o("p",[t._v("props: 所有的 props 对象\nchildren: VNode 子节点数组\nscopedSlots: (vue2.6.0+) 暴露传入作用域插槽的对象。将普通插槽作为函数暴露出去\ndata: 全部的数据对象,作为 createElement 函数的第二个参数传递给组件\nparent: 对父组件的引用\nlisteners: (vue2.3.0+) 包含父级注册的事件侦听器的对象。也是 data.on 的别名\ninjections: (v2.3.0+)  如果使用了 inject 选项，则该对象包含了应当被注入的属性")]),t._v(" "),o("p",[t._v("访问这个 context 参数非常简单，例如，我们想使用 props，可以这样做：")]),t._v(" "),o("ol",[o("li",[t._v("在 Template 中访问组件的 context:")])]),t._v(" "),o("p",[o("img",{attrs:{src:n(57),alt:"template"}})]),t._v(" "),o("ol",{attrs:{start:"2"}},[o("li",[t._v("在 render 函数中访问组件的 context")])]),t._v(" "),o("p",[o("img",{attrs:{src:n(58),alt:"render"}})]),t._v(" "),o("h2",{attrs:{id:"函数式组件的优点"}},[t._v("函数式组件的优点")]),t._v(" "),o("h3",{attrs:{id:"速度"}},[t._v("速度")]),t._v(" "),o("p",[t._v("因为函数式组件没有状态，所以它们不需要像Vue的响应式系统一样需要经过额外的初始化。")]),t._v(" "),o("p",[t._v("函数式组件仍然会对相应的变化做出响应式改变，比如新传入新的 props，但是在组件本身中，它无法知道数据何时发生了更改，因为它不维护自己的状态。")]),t._v(" "),o("p",[t._v("我做了一个基准测试，渲染1000个列表(<li>)，有状态组件和函数式组件，有状态组件耗时110 ~ 120ms，函数式组件耗时20 ~ 30ms。")]),t._v(" "),o("p",[t._v("对于大型应用程序，在使用函数式组件之后，你会看到DOM的渲染、更新会有重大改进。")])])}),[],!1,null,null,null);"function"==typeof s&&s(p);e.default=p.exports},57:function(t,e,n){t.exports=n.p+"images/functional-comp-template.0b40e197.jpg"},58:function(t,e,n){t.exports=n.p+"images/functional-comp-render.8dc9e503.jpg"}}]);