(window.webpackJsonp=window.webpackJsonp||[]).push([[15],{75:function(t,e,o){"use strict";o.r(e);var p=o(0),a=function(t){var e,o,p,a=(p="post",(e={}).internal=o=void 0,e.contentType="markdown",e.slug="20180130-Object对象",e.content=o,e.title="Object对象",e.layout=p,e.markdownHeadings=[{text:"描述",slug:"描述",level:2},{text:"属性",slug:"属性",level:2},{text:"方法",slug:"方法",level:2},{text:"Object方法",slug:"object方法",level:2}],e.excerpt="<p>几乎所有的 JavaScript 对象都是 Object 的实例；一个典型的对象继承了Object.prototype的属性（包括方法），尽管这些属性可能被遮蔽（也被称为覆盖）。然而，一个Object可能是故意创建的，这是不确定的（例如通过Object.create(null)），或者它可能被改变，所以这不再是准确的（例如Object.setPrototypeOf）。</p>\n",e.createdAt=new Date(15172704e5),e.updatedAt=new Date(1568883775412),e.type=p,e.permalink="/posts/20180130-Object对象.html",e.assets={},e.attributes=e,e.prevPost={title:"async和await",permalink:"/posts/20170817-async和await.html"},e.nextPost={title:"react之setState的坑",permalink:"/posts/20180717-react之setState的坑.html"},e),r=t.options.beforeCreate||[];t.options.beforeCreate=[function(){this.$page=a}].concat(r);["layout","transition"].forEach((function(e){var o=t.options.PageComponent;o&&(t.options[e]=o[e]),void 0===t.options[e]&&(t.options[e]=a[e])})),t.options.name="page-wrapper-"+a.slug.replace(/[^0-9a-z\-]/i,"-")},r=Object(p.a)({},(function(){var t=this,e=t.$createElement,o=t._self._c||e;return o("layout-manager",[o("h2",{attrs:{id:"描述"}},[t._v("描述")]),t._v(" "),o("p",[t._v("几乎所有的 JavaScript 对象都是 Object 的实例；一个典型的对象继承了Object.prototype的属性（包括方法），尽管这些属性可能被遮蔽（也被称为覆盖）。然而，一个Object可能是故意创建的，这是不确定的（例如通过Object.create(null)），或者它可能被改变，所以这不再是准确的（例如Object.setPrototypeOf）。")]),t._v(" "),o("p",[t._v("改变Object原型，会通过原型链，而改变所有对象；除非这些属性和方法被其他对原型链更里层的改动所覆盖。这提供了一个非常强大的、但有潜在危险的机制，来覆盖或扩展对象行为。")]),t._v(" "),o("h2",{attrs:{id:"属性"}},[t._v("属性")]),t._v(" "),o("p",[o("em",[t._v("Object.prototype.constructor")]),t._v(" 特定的函数，用于创建一个对象的原型")]),t._v(" "),o("h2",{attrs:{id:"方法"}},[t._v("方法")]),t._v(" "),o("p",[o("em",[t._v("Object.prototype.hasOwnProperty")]),t._v(" 返回一个布尔值 ，表示某个对象是否含有指定的属性，而且此属性非原型链继承的。")]),t._v(" "),o("p",[o("em",[t._v("Object.prototype.isPrototypeOf")]),t._v(" 返回一个布尔值，表示指定的对象是否在本对象的原型链中。")]),t._v(" "),o("p",[o("em",[t._v("Object.prototype.propertyIsEnumerable")]),t._v(" 判断指定属性是否可枚举，内部属性设置参见 ECMAScript [[Enumerable]] attribute 。")]),t._v(" "),o("p",[o("em",[t._v("Object.prototype.toString")]),t._v(" 返回对象的字符串表示。")]),t._v(" "),o("p",[o("em",[t._v("Object.prototype.unwatch")]),t._v(" 移除对象某个属性的监听。")]),t._v(" "),o("p",[o("em",[t._v("Object.prototype.valueOf")]),t._v(" 返回指定对象的原始值。")]),t._v(" "),o("p",[o("em",[t._v("Object.prototype.watch")]),t._v(" 给对象的某个属性增加监听。")]),t._v(" "),o("h2",{attrs:{id:"object方法"}},[t._v("Object方法")]),t._v(" "),o("p",[o("em",[t._v("Object.assign(target, ...sources)")]),t._v(" 将所有可枚举属性的值从一个或多个源对象复制到目标对象。它将返回目标对象。")]),t._v(" "),o("p",[t._v("target: 目标对象。 sources: 源对象。 针对深拷贝，需要使用其他方法，因为 Object.assign()拷贝的是属性值。假如源对象的属性值是一个指向对象的引用，它也只拷贝那个引用值。")]),t._v(" "),o("blockquote",[o("p",[t._v("注意，Object.assign 会跳过那些值为 null 或 undefined 的源对象")])]),t._v(" "),o("p",[o("em",[t._v("Object.create(proto[, propertiesObject])")]),t._v(" 使用指定的原型对象及其属性去创建一个新的对象。")])])}),[],!1,null,null,null);"function"==typeof a&&a(r);e.default=r.exports}}]);